{"ast":null,"code":"import * as i0 from \"@angular/core\";\nimport * as i1 from \"./hooks-parent/hooks-parent.component\";\nexport let HooksComponent = /*#__PURE__*/(() => {\n  class HooksComponent {\n    constructor() {}\n\n    ngOnInit() {}\n\n  }\n\n  HooksComponent.ɵfac = function HooksComponent_Factory(t) {\n    return new (t || HooksComponent)();\n  };\n\n  HooksComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: HooksComponent,\n    selectors: [[\"app-hooks\"]],\n    decls: 83,\n    vars: 0,\n    consts: [[1, \"container\", \"hooks\"], [1, \"content\"]],\n    template: function HooksComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1)(2, \"h5\")(3, \"span\");\n        i0.ɵɵtext(4, \"Constructor() :-\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtext(5, \" Constructor is the default method for a class that is created when a class is installed\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(6, \"span\");\n        i0.ɵɵtext(7, \"Usage :-\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(8, \"p\");\n        i0.ɵɵtext(9, \"Ite is used to pass dependency injuction of a class as a parameter,accessing variables and functions using this key word\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(10, \"h5\")(11, \"span\");\n        i0.ɵɵtext(12, \"ngOnChanges() :-\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtext(13, \" When an input/output binding value changes.\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(14, \"span\");\n        i0.ɵɵtext(15, \"Usage :-\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(16, \"p\");\n        i0.ɵɵtext(17, \"Use ngOnChanges whenever you want to detect changes from a variable decorated by @Input. Remember that only changes from the parent component will trigger this function.\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(18, \"p\");\n        i0.ɵɵtext(19, \"Also remember that changes from the parent still update the child value even without implementing ngOnChanges. ngOnChanges simply adds the benefit of tracking those changes with previous and current value. \");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(20, \"h5\")(21, \"span\");\n        i0.ɵɵtext(22, \"ngOnInit() :-\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtext(23, \" ngOnInit gets called only once when the component is initialized and after ngOnChanges\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(24, \"span\");\n        i0.ɵɵtext(25, \"Usage :-\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(26, \"p\");\n        i0.ɵɵtext(27, \"As it gets called after component initialized so,it is better to use for api calls\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(28, \"p\");\n        i0.ɵɵtext(29, \"Use ngOnInit() whenever you want to execute code when the component is FIRST initialized. Remember that ngOnInit() only fires once after data-bound properties are set. This means ngOnInit() will execute if you refresh your browser or first initialize a component but not when other events occur\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(30, \"h5\")(31, \"span\");\n        i0.ɵɵtext(32, \"ngDoCheck() :-\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtext(33, \" ngDoCheck() is called immediately after ngOnChanges() and ngOnInit().\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(34, \"span\");\n        i0.ɵɵtext(35, \"Usage :-\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(36, \"p\");\n        i0.ɵɵtext(37, \"It is used to check both in parent and child components for @Input Value changes where as ngOnChange will gives result for child component @Input value changes\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(38, \"h5\")(39, \"span\");\n        i0.ɵɵtext(40, \"ngAfterContentInit() :-\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtext(41, \" runs once after the first ngDoCheck().\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(42, \"span\");\n        i0.ɵɵtext(43, \"Usage :-\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(44, \"p\");\n        i0.ɵɵtext(45, \" This is called after components external content has been initialized.\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(46, \"h5\")(47, \"span\");\n        i0.ɵɵtext(48, \"ngAfterContentChecked() :-\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtext(49, \"is called directly after ngAfterContentInit and is called after every subsequent ngDoCheck\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(50, \"span\");\n        i0.ɵɵtext(51, \"Usage :-\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(52, \"p\");\n        i0.ɵɵtext(53, \"Use ngAfterContentChecked whenever you want to call a lifecycle event hook immediately after ngDoCheck.\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(54, \"p\");\n        i0.ɵɵtext(55, \"ngAfterContentChecked can be useful if you want to implement additional initialization tasks after Angular has fully initialized the component/directive's content.\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(56, \"h5\")(57, \"span\");\n        i0.ɵɵtext(58, \"ngAfterViewInit() :-\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtext(59, \" is called once after ngAfterContentChecked and is called after all child components are initialized and checked.\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(60, \"span\");\n        i0.ɵɵtext(61, \"Usage :-\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(62, \"p\");\n        i0.ɵɵtext(63, \"ngAfterViewInit is useful when you want to call a lifecycle hook after all child components have been initialized and checked\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(64, \"h5\")(65, \"span\");\n        i0.ɵɵtext(66, \"ngAfterViewChecked() :-\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtext(67, \" is called after ngAfterContentInit and is called after every subsequent ngAfterContentChecked.\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(68, \"span\");\n        i0.ɵɵtext(69, \"Usage :-\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(70, \"p\");\n        i0.ɵɵtext(71, \"ngAfterViewChecked is useful when you want to call a lifecycle hook after all child components have been initialized and checked.\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(72, \"h5\")(73, \"span\");\n        i0.ɵɵtext(74, \"ngOnDestroy() :-\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtext(75, \" gets called when a component is about to be destroyed\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(76, \"span\");\n        i0.ɵɵtext(77, \"Usage :-\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(78, \"p\");\n        i0.ɵɵtext(79, \"Using ngOnDestroy makes sense when you want to implement customized behavior when a component is destroyed.\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(80, \"p\");\n        i0.ɵɵtext(81, \"ngOnDestroy can be helpful when you need to unsubscribe from observables or perform any other clean up when destroying a component.\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelement(82, \"app-hooks-parent\");\n        i0.ɵɵelementEnd();\n      }\n    },\n    directives: [i1.HooksParentComponent],\n    styles: [\".hooks[_ngcontent-%COMP%]{padding:25px;background-color:#6495ed}\"]\n  });\n  return HooksComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}